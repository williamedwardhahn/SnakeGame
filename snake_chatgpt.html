<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Emoji Snake üêç</title>
  <style>
    :root{
      --bg:#0b0f1a;
      --panel:#121a2a;
      --grid:#0f1626;
      --line:rgba(255,255,255,.06);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 20% 10%, rgba(108,99,255,.22), transparent 60%),
                  radial-gradient(900px 500px at 80% 0%, rgba(0,212,255,.14), transparent 55%),
                  radial-gradient(900px 700px at 30% 90%, rgba(0,255,170,.08), transparent 60%),
                  var(--bg);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }
    .wrap{
      width:min(920px, 100%);
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:18px;
    }
    @media (max-width: 860px){
      .wrap{ grid-template-columns: 1fr; }
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .topbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:14px 16px;
      background: rgba(0,0,0,.18);
      border-bottom:1px solid rgba(255,255,255,.08);
      gap:12px;
      flex-wrap:wrap;
    }
    .title{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:700;
      letter-spacing:.2px;
    }
    .title span.badge{
      font-weight:600;
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      color:var(--muted);
    }
    .stats{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      color:var(--muted);
      font-size:13px;
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      display:flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }
    .pill b{ color:var(--text); font-weight:700; }
    .game{
      padding:16px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    canvas{
      width:min(560px, 100%);
      aspect-ratio: 1 / 1;
      height:auto;
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
      touch-action: none;
    }

    .side{
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .section{
      background: rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:12px;
    }
    .section h3{
      margin:0 0 8px 0;
      font-size:14px;
      color:var(--text);
      letter-spacing:.2px;
    }
    .section p{
      margin:0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button, select{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      cursor:pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      box-shadow: 0 8px 18px rgba(0,0,0,.18);
    }
    button:hover, select:hover{
      background: rgba(255,255,255,.09);
      border-color: rgba(255,255,255,.20);
    }
    button:active{ transform: translateY(1px); }
    button.secondary{
      background: rgba(0,0,0,.18);
    }
    select{
      font-weight:700;
    }
    .hint{
      margin-top:8px;
      color:rgba(255,255,255,.55);
      font-size:12px;
    }
    .toast{
      margin-top:8px;
      padding:10px 12px;
      border-radius:12px;
      border:1px dashed rgba(255,255,255,.16);
      color: rgba(255,255,255,.78);
      font-size:13px;
      display:none;
    }
    .toast.show{ display:block; }
    kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.24);
      color: rgba(255,255,255,.85);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar">
        <div class="title">
          <div style="font-size:18px">üêç Emoji Snake</div>
          <span class="badge">single-page</span>
        </div>
        <div class="stats">
          <div class="pill">Score: <b id="score">0</b></div>
          <div class="pill">Best: <b id="best">0</b></div>
          <div class="pill">Speed: <b id="spd">1.0√ó</b></div>
          <div class="pill" id="state">Ready</div>
        </div>
      </div>
      <div class="game">
        <canvas id="c" width="560" height="560" aria-label="Snake canvas"></canvas>
      </div>
    </div>

    <div class="card side">
      <div class="section">
        <h3>Controls</h3>
        <p>
          Move with <kbd>Arrow</kbd> keys or <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd>.
          <br/>Pause with <kbd>Space</kbd>. Restart with <kbd>R</kbd>.
        </p>
        <div class="hint">On mobile: swipe on the board.</div>
      </div>

      <div class="section">
        <h3>Settings</h3>
        <div class="row">
          <button id="btnStart">Start</button>
          <button id="btnPause" class="secondary">Pause</button>
          <button id="btnRestart" class="secondary">Restart</button>
        </div>
        <div class="row">
          <label style="display:flex;flex-direction:column;gap:6px;min-width:140px">
            <span style="color:var(--muted);font-size:12px;font-weight:700;">Difficulty</span>
            <select id="difficulty">
              <option value="easy">Easy</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Hard</option>
              <option value="insane">Insane</option>
            </select>
          </label>
          <label style="display:flex;flex-direction:column;gap:6px;min-width:140px">
            <span style="color:var(--muted);font-size:12px;font-weight:700;">Food</span>
            <select id="foodEmoji">
              <option value="üçé" selected>üçé Apple</option>
              <option value="üçì">üçì Strawberry</option>
              <option value="üçï">üçï Pizza</option>
              <option value="üç£">üç£ Sushi</option>
              <option value="üßÅ">üßÅ Cupcake</option>
              <option value="üç™">üç™ Cookie</option>
              <option value="ü´ê">ü´ê Blueberries</option>
            </select>
          </label>
        </div>
        <div class="toast" id="toast"></div>
      </div>

      <div class="section">
        <h3>How it works</h3>
        <p>
          The board is a grid. Snake segments and food are drawn as emojis.
          You can‚Äôt reverse direction into yourself.
        </p>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');

      const elScore = document.getElementById('score');
      const elBest  = document.getElementById('best');
      const elSpd   = document.getElementById('spd');
      const elState = document.getElementById('state');
      const toast   = document.getElementById('toast');

      const btnStart   = document.getElementById('btnStart');
      const btnPause   = document.getElementById('btnPause');
      const btnRestart = document.getElementById('btnRestart');
      const selDiff    = document.getElementById('difficulty');
      const selFood    = document.getElementById('foodEmoji');

      // ---- Config
      const GRID = 20; // 20x20
      const CELL = canvas.width / GRID;

      const emojis = {
        head: "üêç",
        body: "üü©",
        bodyAlt: "üü¢",
        dead: "üíÄ",
      };

      const speedByDiff = {
        easy:   7,
        normal: 10,
        hard:   14,
        insane: 18
      };

      const bestKey = "emoji-snake-best-v1";
      let best = Number(localStorage.getItem(bestKey) || 0);
      elBest.textContent = best;

      // ---- State
      let snake, dir, nextDir, food, score, alive, running, paused;
      let tickMs = 1000 / speedByDiff[selDiff.value];
      let last = 0;

      function showToast(msg){
        toast.textContent = msg;
        toast.classList.add('show');
        clearTimeout(showToast._t);
        showToast._t = setTimeout(() => toast.classList.remove('show'), 1400);
      }

      function setStateLabel(text){
        elState.textContent = text;
      }

      function reset(){
        snake = [
          {x: 9, y: 10},
          {x: 8, y: 10},
          {x: 7, y: 10},
        ];
        dir = {x: 1, y: 0};
        nextDir = {x: 1, y: 0};
        score = 0;
        alive = true;
        running = false;
        paused = false;
        spawnFood();
        elScore.textContent = score;
        updateSpeed();
        setStateLabel("Ready");
        draw();
      }

      function updateSpeed(){
        const base = speedByDiff[selDiff.value];
        tickMs = 1000 / base;
        elSpd.textContent = (base / speedByDiff.normal).toFixed(1) + "√ó";
      }

      function inSnake(x,y){
        return snake.some(s => s.x === x && s.y === y);
      }

      function spawnFood(){
        let x, y, tries = 0;
        do{
          x = Math.floor(Math.random()*GRID);
          y = Math.floor(Math.random()*GRID);
          tries++;
        }while(inSnake(x,y) && tries < 500);
        food = {x, y, emoji: selFood.value};
      }

      function start(){
        if(!alive) reset();
        if(!running){
          running = true;
          paused = false;
          setStateLabel("Playing");
          showToast("Go!");
        }
      }

      function togglePause(){
        if(!running) return;
        paused = !paused;
        setStateLabel(paused ? "Paused" : "Playing");
      }

      function gameOver(){
        alive = false;
        running = false;
        paused = false;
        setStateLabel("Game Over");
        showToast("Game Over üí•  Press R");
        if(score > best){
          best = score;
          localStorage.setItem(bestKey, String(best));
          elBest.textContent = best;
        }
        draw(true);
      }

      function step(){
        // Apply queued direction (prevents instant double-turn issues)
        dir = nextDir;

        const head = snake[0];
        const nx = head.x + dir.x;
        const ny = head.y + dir.y;

        // wall collision
        if(nx < 0 || ny < 0 || nx >= GRID || ny >= GRID) return gameOver();

        // self collision (allow moving into tail only if it will move away this tick)
        const willEat = (nx === food.x && ny === food.y);
        const tail = snake[snake.length - 1];
        const hitsBody = snake.some((s, i) => i !== snake.length - 1 && s.x === nx && s.y === ny);
        const hitsTail = (tail.x === nx && tail.y === ny);
        if(hitsBody || (hitsTail && willEat)) return gameOver();

        // move
        snake.unshift({x: nx, y: ny});

        if(willEat){
          score += 1;
          elScore.textContent = score;
          spawnFood();

          // tiny speed-up as you score
          const base = speedByDiff[selDiff.value];
          const bonus = Math.min(6, Math.floor(score / 5));
          const spd = base + bonus;
          tickMs = 1000 / spd;
          elSpd.textContent = (spd / speedByDiff.normal).toFixed(1) + "√ó";
        } else {
          snake.pop();
        }

        draw();
      }

      function draw(isDead=false){
        // background grid
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // grid lines
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--line');
        ctx.lineWidth = 1;
        for(let i=0;i<=GRID;i++){
          const p = i*CELL;
          ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,canvas.height); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(canvas.width,p); ctx.stroke();
        }

        // food
        drawEmoji(food.emoji, food.x, food.y);

        // snake
        for(let i=snake.length-1;i>=0;i--){
          const s = snake[i];
          if(i === 0){
            drawEmoji(isDead ? emojis.dead : emojis.head, s.x, s.y, 1.05);
          } else {
            // alternating body tiles for a little texture
            const e = (i % 2 === 0) ? emojis.body : emojis.bodyAlt;
            drawEmoji(e, s.x, s.y);
          }
        }

        // subtle vignette
        const g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, canvas.width/8, canvas.width/2, canvas.height/2, canvas.width/1.2);
        g.addColorStop(0, "rgba(0,0,0,0)");
        g.addColorStop(1, "rgba(0,0,0,0.28)");
        ctx.fillStyle = g;
        ctx.fillRect(0,0,canvas.width,canvas.height);
      }

      function drawEmoji(emoji, gx, gy, scale=1){
        const x = gx*CELL + CELL/2;
        const y = gy*CELL + CELL/2;

        ctx.save();
        ctx.translate(x,y);
        ctx.scale(scale, scale);

        // font size tuned to cell
        ctx.font = `${Math.floor(CELL*0.9)}px "Apple Color Emoji","Segoe UI Emoji",system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(emoji, 0, 2); // slight baseline tweak
        ctx.restore();
      }

      // ---- Input
      function setDir(dx,dy){
        // block reversing into itself
        if(dir.x === -dx && dir.y === -dy) return;
        nextDir = {x: dx, y: dy};
      }

      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if(["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"," ","r"].includes(k)) e.preventDefault();

        if(k === "arrowup" || k === "w") setDir(0,-1);
        else if(k === "arrowdown" || k === "s") setDir(0,1);
        else if(k === "arrowleft" || k === "a") setDir(-1,0);
        else if(k === "arrowright" || k === "d") setDir(1,0);
        else if(k === " ") togglePause();
        else if(k === "r") { reset(); start(); }
      }, {passive:false});

      // Mobile swipe
      let touchStart = null;
      canvas.addEventListener('pointerdown', (e) => {
        canvas.setPointerCapture(e.pointerId);
        touchStart = {x: e.clientX, y: e.clientY};
      });
      canvas.addEventListener('pointerup', (e) => {
        if(!touchStart) return;
        const dx = e.clientX - touchStart.x;
        const dy = e.clientY - touchStart.y;
        touchStart = null;

        const ax = Math.abs(dx), ay = Math.abs(dy);
        if(Math.max(ax,ay) < 12) return;

        if(ax > ay){
          setDir(dx > 0 ? 1 : -1, 0);
        } else {
          setDir(0, dy > 0 ? 1 : -1);
        }
        start();
      });

      // Buttons + settings
      btnStart.addEventListener('click', () => start());
      btnPause.addEventListener('click', () => togglePause());
      btnRestart.addEventListener('click', () => { reset(); start(); });

      selDiff.addEventListener('change', () => {
        updateSpeed();
        showToast("Difficulty set");
      });

      selFood.addEventListener('change', () => {
        food.emoji = selFood.value;
        draw();
        showToast("Food changed " + selFood.value);
      });

      // ---- Game loop
      function loop(ts){
        requestAnimationFrame(loop);
        if(!running || paused || !alive) return;
        if(!last) last = ts;
        const dt = ts - last;
        if(dt >= tickMs){
          last = ts;
          step();
        }
      }

      reset();
      requestAnimationFrame(loop);

      // Start on first direction key / swipe
      window.addEventListener('keydown', () => { if(!running && alive) start(); }, {once:true});
    })();
  </script>
</body>
</html>
